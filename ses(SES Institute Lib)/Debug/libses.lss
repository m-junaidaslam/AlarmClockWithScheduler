In archive libses.a:

challenge.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000d08  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      0000426b  00000000  00000000  00000d3c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.__vector_17 00000002  00000000  00000000  00004fa7  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .comment      00000031  00000000  00000000  00004fa9  2**0
                  CONTENTS, READONLY

Disassembly of section .text.__vector_17:

00000000 <__vector_17>:
 * the function. Note that a "reti" (return from interrupt)
 * becomes necessary.
 *
 */
ISR(TIMER1_COMPA_vect, ISR_NAKED) {
	asm volatile (
   0:	18 95       	reti

ses_adc.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000f48  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      000043cc  00000000  00000000  00000f7c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.adc_init 0000004c  00000000  00000000  00005348  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .text.adc_read 00000040  00000000  00000000  00005394  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.adc_getJoystickDirection 00000042  00000000  00000000  000053d4  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .comment      00000031  00000000  00000000  00005416  2**0
                  CONTENTS, READONLY

Disassembly of section .text.adc_init:

00000000 <adc_init>:
#define ADC_PORT      			PORTF

/* FUNCTION DEFINITION *******************************************************/

void adc_init(void) {
	DDR_REGISTER(ADC_PORT) &= ~(1 << ADC_MIC_NEG_CH);
   0:	80 98       	cbi	0x10, 0	; 16
	DDR_REGISTER(ADC_PORT) &= ~(1 << ADC_MIC_POS_CH);
   2:	81 98       	cbi	0x10, 1	; 16
	DDR_REGISTER(ADC_PORT) &= ~(1 << ADC_TEMP_CH);
   4:	82 98       	cbi	0x10, 2	; 16
	DDR_REGISTER(ADC_PORT) &= ~(1 << ADC_LIGHT_CH);
   6:	84 98       	cbi	0x10, 4	; 16
	DDR_REGISTER(ADC_PORT) &= ~(1 << ADC_JOYSTICK_CH);
   8:	85 98       	cbi	0x10, 5	; 16

	ADC_PORT &= ~(1 << ADC_MIC_NEG_CH);
   a:	88 98       	cbi	0x11, 0	; 17
	ADC_PORT &= ~(1 << ADC_MIC_POS_CH);
   c:	89 98       	cbi	0x11, 1	; 17
	ADC_PORT &= ~(1 << ADC_TEMP_CH);
   e:	8a 98       	cbi	0x11, 2	; 17
	ADC_PORT &= ~(1 << ADC_LIGHT_CH);
  10:	8c 98       	cbi	0x11, 4	; 17
	ADC_PORT &= ~(1 << ADC_JOYSTICK_CH);
  12:	8d 98       	cbi	0x11, 5	; 17

	PRR0 &= ~(1 << PRADC);
  14:	e4 e6       	ldi	r30, 0x64	; 100
  16:	f0 e0       	ldi	r31, 0x00	; 0
  18:	80 81       	ld	r24, Z
  1a:	8e 7f       	andi	r24, 0xFE	; 254
  1c:	80 83       	st	Z, r24


	// Set reference voltages to internal 1.6V
	ADMUX |= (1 << REFS0);
  1e:	ec e7       	ldi	r30, 0x7C	; 124
  20:	f0 e0       	ldi	r31, 0x00	; 0
  22:	80 81       	ld	r24, Z
  24:	80 64       	ori	r24, 0x40	; 64
  26:	80 83       	st	Z, r24
	ADMUX |= (1 << REFS1);
  28:	80 81       	ld	r24, Z
  2a:	80 68       	ori	r24, 0x80	; 128
  2c:	80 83       	st	Z, r24

	ADMUX &= ~(1 << ADLAR);	// Make ADC right adjusted
  2e:	80 81       	ld	r24, Z
  30:	8f 7d       	andi	r24, 0xDF	; 223
  32:	80 83       	st	Z, r24

	//mask it with prescale for 2Mhz (0x03)
	ADCSRA |= ADC_PRESCALE;
  34:	ea e7       	ldi	r30, 0x7A	; 122
  36:	f0 e0       	ldi	r31, 0x00	; 0
  38:	80 81       	ld	r24, Z
  3a:	83 60       	ori	r24, 0x03	; 3
  3c:	80 83       	st	Z, r24

	//clear auto triggering
	ADCSRA &= ~(1 << ADATE);
  3e:	80 81       	ld	r24, Z
  40:	8f 7d       	andi	r24, 0xDF	; 223
  42:	80 83       	st	Z, r24

	//Enable ADC
	ADCSRA |= (1 << ADEN);
  44:	80 81       	ld	r24, Z
  46:	80 68       	ori	r24, 0x80	; 128
  48:	80 83       	st	Z, r24
  4a:	08 95       	ret

Disassembly of section .text.adc_read:

00000000 <adc_read>:
#define ADC_PORT      			PORTF

/* FUNCTION DEFINITION *******************************************************/

void adc_init(void) {
	DDR_REGISTER(ADC_PORT) &= ~(1 << ADC_MIC_NEG_CH);
   0:	88 30       	cpi	r24, 0x08	; 8
	DDR_REGISTER(ADC_PORT) &= ~(1 << ADC_MIC_POS_CH);
   2:	00 f4       	brcc	.+0      	; 0x4 <adc_read+0x4>
	DDR_REGISTER(ADC_PORT) &= ~(1 << ADC_TEMP_CH);
   4:	ec e7       	ldi	r30, 0x7C	; 124
	DDR_REGISTER(ADC_PORT) &= ~(1 << ADC_LIGHT_CH);
   6:	f0 e0       	ldi	r31, 0x00	; 0
	DDR_REGISTER(ADC_PORT) &= ~(1 << ADC_JOYSTICK_CH);
   8:	90 81       	ld	r25, Z

	ADC_PORT &= ~(1 << ADC_MIC_NEG_CH);
   a:	90 7e       	andi	r25, 0xE0	; 224
	ADC_PORT &= ~(1 << ADC_MIC_POS_CH);
   c:	90 83       	st	Z, r25
	ADC_PORT &= ~(1 << ADC_TEMP_CH);
   e:	90 81       	ld	r25, Z
	ADC_PORT &= ~(1 << ADC_LIGHT_CH);
  10:	89 2b       	or	r24, r25
	ADC_PORT &= ~(1 << ADC_JOYSTICK_CH);
  12:	80 83       	st	Z, r24

	PRR0 &= ~(1 << PRADC);
  14:	ea e7       	ldi	r30, 0x7A	; 122
  16:	f0 e0       	ldi	r31, 0x00	; 0
  18:	80 81       	ld	r24, Z
  1a:	80 64       	ori	r24, 0x40	; 64
  1c:	80 83       	st	Z, r24


	// Set reference voltages to internal 1.6V
	ADMUX |= (1 << REFS0);
  1e:	80 81       	ld	r24, Z
  20:	86 ff       	sbrs	r24, 6
  22:	00 c0       	rjmp	.+0      	; 0x24 <adc_read+0x24>
  24:	00 00       	nop
  26:	80 81       	ld	r24, Z
	ADMUX |= (1 << REFS1);
  28:	86 fd       	sbrc	r24, 6
  2a:	00 c0       	rjmp	.+0      	; 0x2c <adc_read+0x2c>
  2c:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__SREG__+0x800039>

	ADMUX &= ~(1 << ADLAR);	// Make ADC right adjusted
  30:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__SREG__+0x80003a>

	//mask it with prescale for 2Mhz (0x03)
	ADCSRA |= ADC_PRESCALE;
  34:	90 e0       	ldi	r25, 0x00	; 0
  36:	92 2b       	or	r25, r18
  38:	08 95       	ret
  3a:	8f ef       	ldi	r24, 0xFF	; 255
  3c:	9f ef       	ldi	r25, 0xFF	; 255

	//clear auto triggering
	ADCSRA &= ~(1 << ADATE);
  3e:	08 95       	ret

Disassembly of section .text.adc_getJoystickDirection:

00000000 <adc_getJoystickDirection>:
#define ADC_PORT      			PORTF

/* FUNCTION DEFINITION *******************************************************/

void adc_init(void) {
	DDR_REGISTER(ADC_PORT) &= ~(1 << ADC_MIC_NEG_CH);
   0:	85 e0       	ldi	r24, 0x05	; 5
	DDR_REGISTER(ADC_PORT) &= ~(1 << ADC_MIC_POS_CH);
   2:	0e 94 00 00 	call	0	; 0x0 <adc_getJoystickDirection>
	DDR_REGISTER(ADC_PORT) &= ~(1 << ADC_TEMP_CH);
	DDR_REGISTER(ADC_PORT) &= ~(1 << ADC_LIGHT_CH);
   6:	9c 01       	movw	r18, r24
	DDR_REGISTER(ADC_PORT) &= ~(1 << ADC_JOYSTICK_CH);
   8:	2b 5a       	subi	r18, 0xAB	; 171

	ADC_PORT &= ~(1 << ADC_MIC_NEG_CH);
   a:	31 09       	sbc	r19, r1
	ADC_PORT &= ~(1 << ADC_MIC_POS_CH);
   c:	2b 33       	cpi	r18, 0x3B	; 59
	ADC_PORT &= ~(1 << ADC_TEMP_CH);
   e:	31 05       	cpc	r19, r1
	ADC_PORT &= ~(1 << ADC_LIGHT_CH);
  10:	00 f0       	brcs	.+0      	; 0x12 <adc_getJoystickDirection+0x12>
	ADC_PORT &= ~(1 << ADC_JOYSTICK_CH);
  12:	28 5c       	subi	r18, 0xC8	; 200

	PRR0 &= ~(1 << PRADC);
  14:	31 09       	sbc	r19, r1
  16:	2b 33       	cpi	r18, 0x3B	; 59
  18:	31 05       	cpc	r19, r1
  1a:	00 f0       	brcs	.+0      	; 0x1c <adc_getJoystickDirection+0x1c>
  1c:	28 5c       	subi	r18, 0xC8	; 200


	// Set reference voltages to internal 1.6V
	ADMUX |= (1 << REFS0);
  1e:	31 09       	sbc	r19, r1
  20:	2b 33       	cpi	r18, 0x3B	; 59
  22:	31 05       	cpc	r19, r1
  24:	00 f0       	brcs	.+0      	; 0x26 <adc_getJoystickDirection+0x26>
  26:	83 50       	subi	r24, 0x03	; 3
	ADMUX |= (1 << REFS1);
  28:	93 40       	sbci	r25, 0x03	; 3
  2a:	cb 97       	sbiw	r24, 0x3b	; 59
  2c:	00 f0       	brcs	.+0      	; 0x2e <adc_getJoystickDirection+0x2e>

	ADMUX &= ~(1 << ADLAR);	// Make ADC right adjusted
  2e:	84 e0       	ldi	r24, 0x04	; 4
  30:	08 95       	ret
  32:	80 e0       	ldi	r24, 0x00	; 0

	//mask it with prescale for 2Mhz (0x03)
	ADCSRA |= ADC_PRESCALE;
  34:	08 95       	ret
  36:	81 e0       	ldi	r24, 0x01	; 1
  38:	08 95       	ret
  3a:	82 e0       	ldi	r24, 0x02	; 2
  3c:	08 95       	ret

	//clear auto triggering
	ADCSRA &= ~(1 << ADATE);
  3e:	83 e0       	ldi	r24, 0x03	; 3
  40:	08 95       	ret

ses_button.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         000010c8  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00004674  00000000  00000000  000010fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.button_init 00000024  00000000  00000000  00005770  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.button_isJoystickPressed 0000000c  00000000  00000000  00005794  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .text.button_isRotaryPressed 0000000e  00000000  00000000  000057a0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .text.button_setRotaryButtonCallback 0000000a  00000000  00000000  000057ae  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.button_setJoystickButtonCallback 0000000a  00000000  00000000  000057b8  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text.__vector_9 0000006c  00000000  00000000  000057c2  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .text.button_checkState 000000a0  00000000  00000000  0000582e  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 12 .bss.state.2947 00000005  00000000  00000000  000058ce  2**0
                  ALLOC
 13 .bss.index.2948 00000001  00000000  00000000  000058ce  2**0
                  ALLOC
 14 .bss.debouncedState.2949 00000001  00000000  00000000  000058ce  2**0
                  ALLOC
 15 .comment      00000031  00000000  00000000  000058ce  2**0
                  CONTENTS, READONLY

Disassembly of section .text.button_init:

00000000 <button_init>:

pButtonCallback buttonJoystickCallBack;
/* FUNCTION DEFINITION *******************************************************/

void button_init(bool debouncing) {
	DDR_REGISTER(BUTTON_PORT) &= ~(1 << BUTTON_ROTARY_PIN);
   0:	26 98       	cbi	0x04, 6	; 4
	DDR_REGISTER(BUTTON_PORT) &= ~(1 << BUTTON_JOYSTICK_PIN);
   2:	27 98       	cbi	0x04, 7	; 4
	BUTTON_PORT |= (1 << BUTTON_ROTARY_PIN);
   4:	2e 9a       	sbi	0x05, 6	; 5
	BUTTON_PORT |= (1 << BUTTON_JOYSTICK_PIN);
   6:	2f 9a       	sbi	0x05, 7	; 5

	if (debouncing) {
   8:	81 11       	cpse	r24, r1
   a:	00 c0       	rjmp	.+0      	; 0xc <button_init+0xc>
		//timer1_start();
		//timer1_setCallback(&button_checkState);
	} else {
		//initialization for direct interrupts (e.g. setting up the PCICR register)
		// For interrupts
		PCICR |= MSK0_ENABLE;
   c:	e8 e6       	ldi	r30, 0x68	; 104
   e:	f0 e0       	ldi	r31, 0x00	; 0
  10:	80 81       	ld	r24, Z
  12:	81 60       	ori	r24, 0x01	; 1
  14:	80 83       	st	Z, r24
		PCMSK0 |= ((1 << BUTTON_ROTARY_PIN) | (1 << BUTTON_JOYSTICK_PIN));
  16:	eb e6       	ldi	r30, 0x6B	; 107
  18:	f0 e0       	ldi	r31, 0x00	; 0
  1a:	80 81       	ld	r24, Z
  1c:	80 6c       	ori	r24, 0xC0	; 192
  1e:	80 83       	st	Z, r24
	}
	sei();
  20:	78 94       	sei
  22:	08 95       	ret

Disassembly of section .text.button_isJoystickPressed:

00000000 <button_isJoystickPressed>:

pButtonCallback buttonJoystickCallBack;
/* FUNCTION DEFINITION *******************************************************/

void button_init(bool debouncing) {
	DDR_REGISTER(BUTTON_PORT) &= ~(1 << BUTTON_ROTARY_PIN);
   0:	83 b1       	in	r24, 0x03	; 3
	DDR_REGISTER(BUTTON_PORT) &= ~(1 << BUTTON_JOYSTICK_PIN);
   2:	80 95       	com	r24
	BUTTON_PORT |= (1 << BUTTON_ROTARY_PIN);
   4:	88 1f       	adc	r24, r24
	BUTTON_PORT |= (1 << BUTTON_JOYSTICK_PIN);
   6:	88 27       	eor	r24, r24

	if (debouncing) {
   8:	88 1f       	adc	r24, r24
   a:	08 95       	ret

Disassembly of section .text.button_isRotaryPressed:

00000000 <button_isRotaryPressed>:

pButtonCallback buttonJoystickCallBack;
/* FUNCTION DEFINITION *******************************************************/

void button_init(bool debouncing) {
	DDR_REGISTER(BUTTON_PORT) &= ~(1 << BUTTON_ROTARY_PIN);
   0:	83 b1       	in	r24, 0x03	; 3
	DDR_REGISTER(BUTTON_PORT) &= ~(1 << BUTTON_JOYSTICK_PIN);
   2:	86 fb       	bst	r24, 6
	BUTTON_PORT |= (1 << BUTTON_ROTARY_PIN);
   4:	88 27       	eor	r24, r24
	BUTTON_PORT |= (1 << BUTTON_JOYSTICK_PIN);
   6:	80 f9       	bld	r24, 0

	if (debouncing) {
   8:	91 e0       	ldi	r25, 0x01	; 1
   a:	89 27       	eor	r24, r25
		//timer1_start();
		//timer1_setCallback(&button_checkState);
	} else {
		//initialization for direct interrupts (e.g. setting up the PCICR register)
		// For interrupts
		PCICR |= MSK0_ENABLE;
   c:	08 95       	ret

Disassembly of section .text.button_setRotaryButtonCallback:

00000000 <button_setRotaryButtonCallback>:

pButtonCallback buttonJoystickCallBack;
/* FUNCTION DEFINITION *******************************************************/

void button_init(bool debouncing) {
	DDR_REGISTER(BUTTON_PORT) &= ~(1 << BUTTON_ROTARY_PIN);
   0:	90 93 00 00 	sts	0x0000, r25	; 0x800000 <__SREG__+0x7fffc1>
	DDR_REGISTER(BUTTON_PORT) &= ~(1 << BUTTON_JOYSTICK_PIN);
	BUTTON_PORT |= (1 << BUTTON_ROTARY_PIN);
   4:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
	BUTTON_PORT |= (1 << BUTTON_JOYSTICK_PIN);

	if (debouncing) {
   8:	08 95       	ret

Disassembly of section .text.button_setJoystickButtonCallback:

00000000 <button_setJoystickButtonCallback>:

pButtonCallback buttonJoystickCallBack;
/* FUNCTION DEFINITION *******************************************************/

void button_init(bool debouncing) {
	DDR_REGISTER(BUTTON_PORT) &= ~(1 << BUTTON_ROTARY_PIN);
   0:	90 93 00 00 	sts	0x0000, r25	; 0x800000 <__SREG__+0x7fffc1>
	DDR_REGISTER(BUTTON_PORT) &= ~(1 << BUTTON_JOYSTICK_PIN);
	BUTTON_PORT |= (1 << BUTTON_ROTARY_PIN);
   4:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
	BUTTON_PORT |= (1 << BUTTON_JOYSTICK_PIN);

	if (debouncing) {
   8:	08 95       	ret

Disassembly of section .text.__vector_9:

00000000 <__vector_9>:

pButtonCallback buttonJoystickCallBack;
/* FUNCTION DEFINITION *******************************************************/

void button_init(bool debouncing) {
	DDR_REGISTER(BUTTON_PORT) &= ~(1 << BUTTON_ROTARY_PIN);
   0:	1f 92       	push	r1
	DDR_REGISTER(BUTTON_PORT) &= ~(1 << BUTTON_JOYSTICK_PIN);
   2:	0f 92       	push	r0
	BUTTON_PORT |= (1 << BUTTON_ROTARY_PIN);
   4:	0f b6       	in	r0, 0x3f	; 63
	BUTTON_PORT |= (1 << BUTTON_JOYSTICK_PIN);
   6:	0f 92       	push	r0

	if (debouncing) {
   8:	11 24       	eor	r1, r1
   a:	0b b6       	in	r0, 0x3b	; 59
		//timer1_start();
		//timer1_setCallback(&button_checkState);
	} else {
		//initialization for direct interrupts (e.g. setting up the PCICR register)
		// For interrupts
		PCICR |= MSK0_ENABLE;
   c:	0f 92       	push	r0
   e:	2f 93       	push	r18
  10:	3f 93       	push	r19
  12:	4f 93       	push	r20
  14:	5f 93       	push	r21
		PCMSK0 |= ((1 << BUTTON_ROTARY_PIN) | (1 << BUTTON_JOYSTICK_PIN));
  16:	6f 93       	push	r22
  18:	7f 93       	push	r23
  1a:	8f 93       	push	r24
  1c:	9f 93       	push	r25
  1e:	af 93       	push	r26
	}
	sei();
  20:	bf 93       	push	r27
  22:	ef 93       	push	r30
  24:	ff 93       	push	r31
  26:	1f 99       	sbic	0x03, 7	; 3
  28:	00 c0       	rjmp	.+0      	; 0x2a <__vector_9+0x2a>
  2a:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  2e:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  32:	09 95       	icall
  34:	0e 94 00 00 	call	0	; 0x0 <__vector_9>
  38:	88 23       	and	r24, r24
  3a:	01 f0       	breq	.+0      	; 0x3c <__vector_9+0x3c>
  3c:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  40:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  44:	09 95       	icall
  46:	ff 91       	pop	r31
  48:	ef 91       	pop	r30
  4a:	bf 91       	pop	r27
  4c:	af 91       	pop	r26
  4e:	9f 91       	pop	r25
  50:	8f 91       	pop	r24
  52:	7f 91       	pop	r23
  54:	6f 91       	pop	r22
  56:	5f 91       	pop	r21
  58:	4f 91       	pop	r20
  5a:	3f 91       	pop	r19
  5c:	2f 91       	pop	r18
  5e:	0f 90       	pop	r0
  60:	0b be       	out	0x3b, r0	; 59
  62:	0f 90       	pop	r0
  64:	0f be       	out	0x3f, r0	; 63
  66:	0f 90       	pop	r0
  68:	1f 90       	pop	r1
  6a:	18 95       	reti

Disassembly of section .text.button_checkState:

00000000 <button_checkState>:

pButtonCallback buttonJoystickCallBack;
/* FUNCTION DEFINITION *******************************************************/

void button_init(bool debouncing) {
	DDR_REGISTER(BUTTON_PORT) &= ~(1 << BUTTON_ROTARY_PIN);
   0:	0f 93       	push	r16
	DDR_REGISTER(BUTTON_PORT) &= ~(1 << BUTTON_JOYSTICK_PIN);
   2:	1f 93       	push	r17
	BUTTON_PORT |= (1 << BUTTON_ROTARY_PIN);
   4:	cf 93       	push	r28
	BUTTON_PORT |= (1 << BUTTON_JOYSTICK_PIN);
   6:	df 93       	push	r29

	if (debouncing) {
   8:	d0 91 00 00 	lds	r29, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
		//timer1_start();
		//timer1_setCallback(&button_checkState);
	} else {
		//initialization for direct interrupts (e.g. setting up the PCICR register)
		// For interrupts
		PCICR |= MSK0_ENABLE;
   c:	c0 91 00 00 	lds	r28, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  10:	0c 2f       	mov	r16, r28
  12:	10 e0       	ldi	r17, 0x00	; 0
  14:	f8 01       	movw	r30, r16
		PCMSK0 |= ((1 << BUTTON_ROTARY_PIN) | (1 << BUTTON_JOYSTICK_PIN));
  16:	e0 50       	subi	r30, 0x00	; 0
  18:	f0 40       	sbci	r31, 0x00	; 0
  1a:	10 82       	st	Z, r1
  1c:	1f 99       	sbic	0x03, 7	; 3
  1e:	00 c0       	rjmp	.+0      	; 0x20 <button_checkState+0x20>
	}
	sei();
  20:	81 e0       	ldi	r24, 0x01	; 1
  22:	f8 01       	movw	r30, r16
  24:	e0 50       	subi	r30, 0x00	; 0
  26:	f0 40       	sbci	r31, 0x00	; 0
  28:	80 83       	st	Z, r24
  2a:	0e 94 00 00 	call	0	; 0x0 <button_checkState>
  2e:	88 23       	and	r24, r24
  30:	01 f0       	breq	.+0      	; 0x32 <button_checkState+0x32>
  32:	f8 01       	movw	r30, r16
  34:	e0 50       	subi	r30, 0x00	; 0
  36:	f0 40       	sbci	r31, 0x00	; 0
  38:	80 81       	ld	r24, Z
  3a:	82 60       	ori	r24, 0x02	; 2
  3c:	80 83       	st	Z, r24
  3e:	cf 5f       	subi	r28, 0xFF	; 255
  40:	c5 30       	cpi	r28, 0x05	; 5
  42:	01 f0       	breq	.+0      	; 0x44 <button_checkState+0x44>
  44:	c0 93 00 00 	sts	0x0000, r28	; 0x800000 <__SREG__+0x7fffc1>
  48:	00 c0       	rjmp	.+0      	; 0x4a <button_checkState+0x4a>
  4a:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
  4e:	e0 e0       	ldi	r30, 0x00	; 0
  50:	f0 e0       	ldi	r31, 0x00	; 0
  52:	20 e0       	ldi	r18, 0x00	; 0
  54:	30 e0       	ldi	r19, 0x00	; 0
  56:	8f ef       	ldi	r24, 0xFF	; 255
  58:	91 91       	ld	r25, Z+
  5a:	89 23       	and	r24, r25
  5c:	e2 17       	cp	r30, r18
  5e:	f3 07       	cpc	r31, r19
  60:	01 f4       	brne	.+0      	; 0x62 <button_checkState+0x62>
  62:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
  66:	d0 fd       	sbrc	r29, 0
  68:	00 c0       	rjmp	.+0      	; 0x6a <button_checkState+0x6a>
  6a:	80 ff       	sbrs	r24, 0
  6c:	00 c0       	rjmp	.+0      	; 0x6e <button_checkState+0x6e>
  6e:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  72:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  76:	30 97       	sbiw	r30, 0x00	; 0
  78:	01 f0       	breq	.+0      	; 0x7a <button_checkState+0x7a>
  7a:	09 95       	icall
  7c:	d1 fd       	sbrc	r29, 1
  7e:	00 c0       	rjmp	.+0      	; 0x80 <button_checkState+0x80>
  80:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  84:	81 ff       	sbrs	r24, 1
  86:	00 c0       	rjmp	.+0      	; 0x88 <button_checkState+0x88>
  88:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  8c:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  90:	30 97       	sbiw	r30, 0x00	; 0
  92:	01 f0       	breq	.+0      	; 0x94 <button_checkState+0x94>
  94:	09 95       	icall
  96:	df 91       	pop	r29
  98:	cf 91       	pop	r28
  9a:	1f 91       	pop	r17
  9c:	0f 91       	pop	r16
  9e:	08 95       	ret

ses_led.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000eb8  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00004379  00000000  00000000  00000eec  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.led_redInit 00000006  00000000  00000000  00005265  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .text.led_redToggle 0000000a  00000000  00000000  0000526b  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .text.led_redOn 00000004  00000000  00000000  00005275  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .text.led_redOff 00000004  00000000  00000000  00005279  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  9 .text.led_yellowInit 00000006  00000000  00000000  0000527d  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 10 .text.led_yellowToggle 00000008  00000000  00000000  00005283  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .text.led_yellowOn 00000004  00000000  00000000  0000528b  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .text.led_yellowOff 00000004  00000000  00000000  0000528f  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .text.led_greenInit 00000006  00000000  00000000  00005293  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .text.led_greenToggle 0000000a  00000000  00000000  00005299  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 15 .text.led_greenOn 00000004  00000000  00000000  000052a3  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .text.led_greenOff 00000004  00000000  00000000  000052a7  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 17 .comment      00000031  00000000  00000000  000052ab  2**0
                  CONTENTS, READONLY

Disassembly of section .text.led_redInit:

00000000 <led_redInit>:
void led_greenOn(void) {
	LED_GREEN_PORT &= ~(1 << LED_GREEN_PIN);
}

void led_greenOff(void) {
	LED_GREEN_PORT |= (1 << LED_GREEN_PIN);
   0:	99 9a       	sbi	0x13, 1	; 19
   2:	a1 9a       	sbi	0x14, 1	; 20
   4:	08 95       	ret

Disassembly of section .text.led_redToggle:

00000000 <led_redToggle>:
   0:	94 b3       	in	r25, 0x14	; 20
   2:	82 e0       	ldi	r24, 0x02	; 2
   4:	89 27       	eor	r24, r25
   6:	84 bb       	out	0x14, r24	; 20
   8:	08 95       	ret

Disassembly of section .text.led_redOn:

00000000 <led_redOn>:
   0:	a1 98       	cbi	0x14, 1	; 20
   2:	08 95       	ret

Disassembly of section .text.led_redOff:

00000000 <led_redOff>:
   0:	a1 9a       	sbi	0x14, 1	; 20
   2:	08 95       	ret

Disassembly of section .text.led_yellowInit:

00000000 <led_yellowInit>:
   0:	87 9a       	sbi	0x10, 7	; 16
   2:	8f 9a       	sbi	0x11, 7	; 17
   4:	08 95       	ret

Disassembly of section .text.led_yellowToggle:

00000000 <led_yellowToggle>:
   0:	81 b3       	in	r24, 0x11	; 17
   2:	80 58       	subi	r24, 0x80	; 128
   4:	81 bb       	out	0x11, r24	; 17
   6:	08 95       	ret

Disassembly of section .text.led_yellowOn:

00000000 <led_yellowOn>:
   0:	8f 98       	cbi	0x11, 7	; 17
   2:	08 95       	ret

Disassembly of section .text.led_yellowOff:

00000000 <led_yellowOff>:
   0:	8f 9a       	sbi	0x11, 7	; 17
   2:	08 95       	ret

Disassembly of section .text.led_greenInit:

00000000 <led_greenInit>:
   0:	86 9a       	sbi	0x10, 6	; 16
   2:	8e 9a       	sbi	0x11, 6	; 17
   4:	08 95       	ret

Disassembly of section .text.led_greenToggle:

00000000 <led_greenToggle>:
   0:	91 b3       	in	r25, 0x11	; 17
   2:	80 e4       	ldi	r24, 0x40	; 64
   4:	89 27       	eor	r24, r25
   6:	81 bb       	out	0x11, r24	; 17
   8:	08 95       	ret

Disassembly of section .text.led_greenOn:

00000000 <led_greenOn>:
   0:	8e 98       	cbi	0x11, 6	; 17
   2:	08 95       	ret

Disassembly of section .text.led_greenOff:

00000000 <led_greenOff>:
   0:	8e 9a       	sbi	0x11, 6	; 17
   2:	08 95       	ret

ses_motorFrequency.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00001080  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00004490  00000000  00000000  000010b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.motorStopped 0000000a  00000000  00000000  00005544  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.motorFrequency_init 00000030  00000000  00000000  0000554e  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.motorFrequency_getRecent 0000002e  00000000  00000000  0000557e  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text.set_portD0CallBack 0000000e  00000000  00000000  000055ac  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.__vector_1 0000008e  00000000  00000000  000055ba  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text.swap    0000001a  00000000  00000000  00005648  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .text.bubbleSort 0000005e  00000000  00000000  00005662  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 12 .text.motorFrequency_getMedian 0000003c  00000000  00000000  000056c0  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 13 .data.counter 00000002  00000000  00000000  000056fc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 14 .bss.MY_TIME  00000002  00000000  00000000  000056fe  2**0
                  ALLOC
 15 .data.COUNT   00000001  00000000  00000000  000056fe  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 16 .comment      00000031  00000000  00000000  000056ff  2**0
                  CONTENTS, READONLY

Disassembly of section .text.motorStopped:

00000000 <motorStopped>:

	}
	return 0;
}

uint16_t motorFrequency_getMedian() {
   0:	0e 94 00 00 	call	0	; 0x0 <motorStopped>
   4:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
   8:	08 95       	ret

Disassembly of section .text.motorFrequency_init:

00000000 <motorFrequency_init>:
   0:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
   4:	0e 94 00 00 	call	0	; 0x0 <motorFrequency_init>
   8:	0e 94 00 00 	call	0	; 0x0 <motorFrequency_init>
   c:	98 98       	cbi	0x13, 0	; 19
   e:	e9 e6       	ldi	r30, 0x69	; 105

	for(int i =0; i < NUM_INTERVALS; i++) {
		my_Array[i] = motorFrequency_getRecent();
  10:	f0 e0       	ldi	r31, 0x00	; 0
  12:	80 81       	ld	r24, Z
  14:	83 60       	ori	r24, 0x03	; 3
  16:	80 83       	st	Z, r24
	return 0;
}

uint16_t motorFrequency_getMedian() {

	for(int i =0; i < NUM_INTERVALS; i++) {
  18:	e8 9a       	sbi	0x1d, 0	; 29
  1a:	8f b7       	in	r24, 0x3f	; 63
  1c:	80 68       	ori	r24, 0x80	; 128
		my_Array[i] = motorFrequency_getRecent();
	}
	bubbleSort(my_Array, NUM_INTERVALS - 1);
  1e:	8f bf       	out	0x3f, r24	; 63
  20:	e0 98       	cbi	0x1c, 0	; 28
  22:	0e 94 00 00 	call	0	; 0x0 <motorFrequency_init>
  26:	80 e0       	ldi	r24, 0x00	; 0
  28:	90 e0       	ldi	r25, 0x00	; 0
	//counter = NUM_INTERVALS-1;
	return my_Array[NUM_INTERVALS / 2];
}
  2a:	0e 94 00 00 	call	0	; 0x0 <motorFrequency_init>
  2e:	08 95       	ret

Disassembly of section .text.motorFrequency_getRecent:

00000000 <motorFrequency_getRecent>:

	}
	return 0;
}

uint16_t motorFrequency_getMedian() {
   0:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   4:	88 23       	and	r24, r24
   6:	01 f0       	breq	.+0      	; 0x8 <motorFrequency_getRecent+0x8>
   8:	60 91 00 00 	lds	r22, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   c:	70 91 00 00 	lds	r23, 0x0000	; 0x800000 <__SREG__+0x7fffc1>

	for(int i =0; i < NUM_INTERVALS; i++) {
		my_Array[i] = motorFrequency_getRecent();
  10:	61 15       	cp	r22, r1
  12:	71 05       	cpc	r23, r1
  14:	01 f0       	breq	.+0      	; 0x16 <motorFrequency_getRecent+0x16>
  16:	88 e5       	ldi	r24, 0x58	; 88
	return 0;
}

uint16_t motorFrequency_getMedian() {

	for(int i =0; i < NUM_INTERVALS; i++) {
  18:	92 e0       	ldi	r25, 0x02	; 2
  1a:	0e 94 00 00 	call	0	; 0x0 <motorFrequency_getRecent>
		my_Array[i] = motorFrequency_getRecent();
	}
	bubbleSort(my_Array, NUM_INTERVALS - 1);
  1e:	cb 01       	movw	r24, r22
  20:	08 95       	ret
  22:	80 e0       	ldi	r24, 0x00	; 0
  24:	90 e0       	ldi	r25, 0x00	; 0
  26:	08 95       	ret
  28:	83 e0       	ldi	r24, 0x03	; 3
	//counter = NUM_INTERVALS-1;
	return my_Array[NUM_INTERVALS / 2];
}
  2a:	90 e0       	ldi	r25, 0x00	; 0
  2c:	08 95       	ret

Disassembly of section .text.set_portD0CallBack:

00000000 <set_portD0CallBack>:

	}
	return 0;
}

uint16_t motorFrequency_getMedian() {
   0:	00 97       	sbiw	r24, 0x00	; 0
   2:	01 f0       	breq	.+0      	; 0x4 <set_portD0CallBack+0x4>
   4:	90 93 00 00 	sts	0x0000, r25	; 0x800000 <__SREG__+0x7fffc1>
   8:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
   c:	08 95       	ret

Disassembly of section .text.__vector_1:

00000000 <__vector_1>:
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	0b b6       	in	r0, 0x3b	; 59
   c:	0f 92       	push	r0
   e:	2f 93       	push	r18

	for(int i =0; i < NUM_INTERVALS; i++) {
		my_Array[i] = motorFrequency_getRecent();
  10:	3f 93       	push	r19
  12:	4f 93       	push	r20
  14:	5f 93       	push	r21
  16:	6f 93       	push	r22
	return 0;
}

uint16_t motorFrequency_getMedian() {

	for(int i =0; i < NUM_INTERVALS; i++) {
  18:	7f 93       	push	r23
  1a:	8f 93       	push	r24
  1c:	9f 93       	push	r25
		my_Array[i] = motorFrequency_getRecent();
	}
	bubbleSort(my_Array, NUM_INTERVALS - 1);
  1e:	af 93       	push	r26
  20:	bf 93       	push	r27
  22:	ef 93       	push	r30
  24:	ff 93       	push	r31
  26:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
	//counter = NUM_INTERVALS-1;
	return my_Array[NUM_INTERVALS / 2];
}
  2a:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  2e:	30 97       	sbiw	r30, 0x00	; 0
  30:	01 f0       	breq	.+0      	; 0x32 <__vector_1+0x32>
  32:	09 95       	icall
  34:	0e 94 00 00 	call	0	; 0x0 <__vector_1>
  38:	81 e0       	ldi	r24, 0x01	; 1
  3a:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
  3e:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  42:	81 11       	cpse	r24, r1
  44:	00 c0       	rjmp	.+0      	; 0x46 <__vector_1+0x46>
  46:	86 e0       	ldi	r24, 0x06	; 6
  48:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
  4c:	e4 e2       	ldi	r30, 0x24	; 36
  4e:	f1 e0       	ldi	r31, 0x01	; 1
  50:	80 81       	ld	r24, Z
  52:	91 81       	ldd	r25, Z+1	; 0x01
  54:	90 93 00 00 	sts	0x0000, r25	; 0x800000 <__SREG__+0x7fffc1>
  58:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
  5c:	11 82       	std	Z+1, r1	; 0x01
  5e:	10 82       	st	Z, r1
  60:	00 c0       	rjmp	.+0      	; 0x62 <__vector_1+0x62>
  62:	81 50       	subi	r24, 0x01	; 1
  64:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
  68:	ff 91       	pop	r31
  6a:	ef 91       	pop	r30
  6c:	bf 91       	pop	r27
  6e:	af 91       	pop	r26
  70:	9f 91       	pop	r25
  72:	8f 91       	pop	r24
  74:	7f 91       	pop	r23
  76:	6f 91       	pop	r22
  78:	5f 91       	pop	r21
  7a:	4f 91       	pop	r20
  7c:	3f 91       	pop	r19
  7e:	2f 91       	pop	r18
  80:	0f 90       	pop	r0
  82:	0b be       	out	0x3b, r0	; 59
  84:	0f 90       	pop	r0
  86:	0f be       	out	0x3f, r0	; 63
  88:	0f 90       	pop	r0
  8a:	1f 90       	pop	r1
  8c:	18 95       	reti

Disassembly of section .text.swap:

00000000 <swap>:

	}
	return 0;
}

uint16_t motorFrequency_getMedian() {
   0:	fc 01       	movw	r30, r24
   2:	20 81       	ld	r18, Z
   4:	31 81       	ldd	r19, Z+1	; 0x01
   6:	fb 01       	movw	r30, r22
   8:	40 81       	ld	r20, Z
   a:	51 81       	ldd	r21, Z+1	; 0x01
   c:	fc 01       	movw	r30, r24
   e:	51 83       	std	Z+1, r21	; 0x01

	for(int i =0; i < NUM_INTERVALS; i++) {
		my_Array[i] = motorFrequency_getRecent();
  10:	40 83       	st	Z, r20
  12:	fb 01       	movw	r30, r22
  14:	31 83       	std	Z+1, r19	; 0x01
  16:	20 83       	st	Z, r18
	return 0;
}

uint16_t motorFrequency_getMedian() {

	for(int i =0; i < NUM_INTERVALS; i++) {
  18:	08 95       	ret

Disassembly of section .text.bubbleSort:

00000000 <bubbleSort>:

	}
	return 0;
}

uint16_t motorFrequency_getMedian() {
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
   8:	61 30       	cpi	r22, 0x01	; 1
   a:	71 05       	cpc	r23, r1
   c:	01 f4       	brne	.+0      	; 0xe <bubbleSort+0xe>
   e:	00 c0       	rjmp	.+0      	; 0x10 <bubbleSort+0x10>

	for(int i =0; i < NUM_INTERVALS; i++) {
		my_Array[i] = motorFrequency_getRecent();
  10:	41 91       	ld	r20, Z+
  12:	51 91       	ld	r21, Z+
  14:	a0 81       	ld	r26, Z
  16:	b1 81       	ldd	r27, Z+1	; 0x01
	return 0;
}

uint16_t motorFrequency_getMedian() {

	for(int i =0; i < NUM_INTERVALS; i++) {
  18:	a4 17       	cp	r26, r20
  1a:	b5 07       	cpc	r27, r21
  1c:	00 f4       	brcc	.+0      	; 0x1e <bubbleSort+0x1e>
		my_Array[i] = motorFrequency_getRecent();
	}
	bubbleSort(my_Array, NUM_INTERVALS - 1);
  1e:	ef 01       	movw	r28, r30
  20:	22 97       	sbiw	r28, 0x02	; 2
  22:	b9 83       	std	Y+1, r27	; 0x01
  24:	a8 83       	st	Y, r26
  26:	51 83       	std	Z+1, r21	; 0x01
  28:	40 83       	st	Z, r20
	//counter = NUM_INTERVALS-1;
	return my_Array[NUM_INTERVALS / 2];
}
  2a:	2f 5f       	subi	r18, 0xFF	; 255
  2c:	3f 4f       	sbci	r19, 0xFF	; 255
  2e:	26 17       	cp	r18, r22
  30:	37 07       	cpc	r19, r23
  32:	01 f4       	brne	.+0      	; 0x34 <bubbleSort+0x34>
  34:	61 50       	subi	r22, 0x01	; 1
  36:	71 09       	sbc	r23, r1
  38:	61 30       	cpi	r22, 0x01	; 1
  3a:	71 05       	cpc	r23, r1
  3c:	01 f4       	brne	.+0      	; 0x3e <bubbleSort+0x3e>
  3e:	00 c0       	rjmp	.+0      	; 0x40 <bubbleSort+0x40>
  40:	01 e0       	ldi	r16, 0x01	; 1
  42:	10 e0       	ldi	r17, 0x00	; 0
  44:	61 30       	cpi	r22, 0x01	; 1
  46:	71 05       	cpc	r23, r1
  48:	01 f0       	breq	.+0      	; 0x4a <bubbleSort+0x4a>
  4a:	e8 2f       	mov	r30, r24
  4c:	f9 2f       	mov	r31, r25
  4e:	20 2f       	mov	r18, r16
  50:	31 2f       	mov	r19, r17
  52:	00 c0       	rjmp	.+0      	; 0x54 <bubbleSort+0x54>
  54:	df 91       	pop	r29
  56:	cf 91       	pop	r28
  58:	1f 91       	pop	r17
  5a:	0f 91       	pop	r16
  5c:	08 95       	ret

Disassembly of section .text.motorFrequency_getMedian:

00000000 <motorFrequency_getMedian>:

	}
	return 0;
}

uint16_t motorFrequency_getMedian() {
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
   8:	c0 e0       	ldi	r28, 0x00	; 0
   a:	d0 e0       	ldi	r29, 0x00	; 0
   c:	00 e0       	ldi	r16, 0x00	; 0
   e:	10 e0       	ldi	r17, 0x00	; 0

	for(int i =0; i < NUM_INTERVALS; i++) {
		my_Array[i] = motorFrequency_getRecent();
  10:	0e 94 00 00 	call	0	; 0x0 <motorFrequency_getMedian>
  14:	89 93       	st	Y+, r24
  16:	99 93       	st	Y+, r25
	return 0;
}

uint16_t motorFrequency_getMedian() {

	for(int i =0; i < NUM_INTERVALS; i++) {
  18:	c0 17       	cp	r28, r16
  1a:	d1 07       	cpc	r29, r17
  1c:	01 f4       	brne	.+0      	; 0x1e <motorFrequency_getMedian+0x1e>
		my_Array[i] = motorFrequency_getRecent();
	}
	bubbleSort(my_Array, NUM_INTERVALS - 1);
  1e:	62 e1       	ldi	r22, 0x12	; 18
  20:	70 e0       	ldi	r23, 0x00	; 0
  22:	80 e0       	ldi	r24, 0x00	; 0
  24:	90 e0       	ldi	r25, 0x00	; 0
  26:	0e 94 00 00 	call	0	; 0x0 <motorFrequency_getMedian>
	//counter = NUM_INTERVALS-1;
	return my_Array[NUM_INTERVALS / 2];
}
  2a:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  2e:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  32:	df 91       	pop	r29
  34:	cf 91       	pop	r28
  36:	1f 91       	pop	r17
  38:	0f 91       	pop	r16
  3a:	08 95       	ret

ses_pwm.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000dc8  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      0000432f  00000000  00000000  00000dfc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.pwm_init 0000002a  00000000  00000000  0000512b  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .text.pwm_setDutyCycle 00000004  00000000  00000000  00005155  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .comment      00000031  00000000  00000000  00005159  2**0
                  CONTENTS, READONLY

Disassembly of section .text.pwm_init:

00000000 <pwm_init>:
#define TCCR_VAL_FOR_OCOB_SET	0x30
#define MOTOR_STOP 				0xFF

/* FUNCTION DEFINITION *******************************************************/
void pwm_init(void) {
	PRR0 &= ~(1 << PRTIM0);	//Start Timer0
   0:	e4 e6       	ldi	r30, 0x64	; 100
   2:	f0 e0       	ldi	r31, 0x00	; 0
   4:	80 81       	ld	r24, Z
   6:	8f 7d       	andi	r24, 0xDF	; 223
   8:	80 83       	st	Z, r24
	TCCR0A |= FAST_PWM_MODE_TIM0;	//Fast PWM Mode
   a:	84 b5       	in	r24, 0x24	; 36
   c:	83 60       	ori	r24, 0x03	; 3
   e:	84 bd       	out	0x24, r24	; 36
	TCCR0B &= ~(1 << WGM02); //Forcefully setting the bit to zero to maintain the value of 0x03 for fast PWM mode.
  10:	85 b5       	in	r24, 0x25	; 37
  12:	87 7f       	andi	r24, 0xF7	; 247
  14:	85 bd       	out	0x25, r24	; 37
	TCCR0B |= NO_PRESCALER_TIM0;//Using the original clock frequency Prescalar is Zero
  16:	85 b5       	in	r24, 0x25	; 37
  18:	81 60       	ori	r24, 0x01	; 1
  1a:	85 bd       	out	0x25, r24	; 37
	TCCR0A |= TCCR_VAL_FOR_OCOB_SET;//configurating Timer Control Register to set bit OC0B when timer value matches OCR0B
  1c:	84 b5       	in	r24, 0x24	; 36
  1e:	80 63       	ori	r24, 0x30	; 48
  20:	84 bd       	out	0x24, r24	; 36
	DDRG |= (1 << PG5);	//Setting Pin 5 of PortG as output.
  22:	9d 9a       	sbi	0x13, 5	; 19
	OCR0B = MOTOR_STOP;
  24:	8f ef       	ldi	r24, 0xFF	; 255
  26:	88 bd       	out	0x28, r24	; 40
  28:	08 95       	ret

Disassembly of section .text.pwm_setDutyCycle:

00000000 <pwm_setDutyCycle>:
#define TCCR_VAL_FOR_OCOB_SET	0x30
#define MOTOR_STOP 				0xFF

/* FUNCTION DEFINITION *******************************************************/
void pwm_init(void) {
	PRR0 &= ~(1 << PRTIM0);	//Start Timer0
   0:	88 bd       	out	0x28, r24	; 40
   2:	08 95       	ret

ses_rotary.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000fe4  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00004492  00000000  00000000  00001018  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.rotary_init 0000000c  00000000  00000000  000054aa  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .text.rotary_isInputAHigh 0000000e  00000000  00000000  000054b6  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .text.rotary_isInputBHigh 0000000e  00000000  00000000  000054c4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .text.rotary_setClockwiseCallback 0000000a  00000000  00000000  000054d2  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.rotary_setCounterClockwiseCallback 0000000a  00000000  00000000  000054dc  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text.rotary_checkState 000000b4  00000000  00000000  000054e6  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .bss.state.2726 00000005  00000000  00000000  0000559a  2**0
                  ALLOC
 12 .bss.index.2727 00000001  00000000  00000000  0000559a  2**0
                  ALLOC
 13 .bss.debouncedState.2728 00000001  00000000  00000000  0000559a  2**0
                  ALLOC
 14 .comment      00000031  00000000  00000000  0000559a  2**0
                  CONTENTS, READONLY

Disassembly of section .text.rotary_init:

00000000 <rotary_init>:
pTypeRotaryCallback rotaryClockwiseCallback;
pTypeRotaryCallback rotaryCounterClockwiseCallback;
/* FUNCTION DEFINITION *******************************************************/

void rotary_init() {
	DDR_REGISTER(A_ROTARY_PORT) &= ~(1 << A_ROTARY_PIN);
   0:	25 98       	cbi	0x04, 5	; 4
	DDR_REGISTER(B_ROTARY_PORT) &= ~(1 << B_ROTARY_PIN);
   2:	9a 98       	cbi	0x13, 2	; 19
	A_ROTARY_PORT |= (1 << A_ROTARY_PIN);
   4:	2d 9a       	sbi	0x05, 5	; 5
	B_ROTARY_PORT |= (1 << B_ROTARY_PIN);
   6:	a2 9a       	sbi	0x14, 2	; 20

	sei();
   8:	78 94       	sei
   a:	08 95       	ret

Disassembly of section .text.rotary_isInputAHigh:

00000000 <rotary_isInputAHigh>:
pTypeRotaryCallback rotaryClockwiseCallback;
pTypeRotaryCallback rotaryCounterClockwiseCallback;
/* FUNCTION DEFINITION *******************************************************/

void rotary_init() {
	DDR_REGISTER(A_ROTARY_PORT) &= ~(1 << A_ROTARY_PIN);
   0:	83 b1       	in	r24, 0x03	; 3
	DDR_REGISTER(B_ROTARY_PORT) &= ~(1 << B_ROTARY_PIN);
   2:	85 fb       	bst	r24, 5
	A_ROTARY_PORT |= (1 << A_ROTARY_PIN);
   4:	88 27       	eor	r24, r24
	B_ROTARY_PORT |= (1 << B_ROTARY_PIN);
   6:	80 f9       	bld	r24, 0

	sei();
   8:	91 e0       	ldi	r25, 0x01	; 1
   a:	89 27       	eor	r24, r25
   c:	08 95       	ret

Disassembly of section .text.rotary_isInputBHigh:

00000000 <rotary_isInputBHigh>:
pTypeRotaryCallback rotaryClockwiseCallback;
pTypeRotaryCallback rotaryCounterClockwiseCallback;
/* FUNCTION DEFINITION *******************************************************/

void rotary_init() {
	DDR_REGISTER(A_ROTARY_PORT) &= ~(1 << A_ROTARY_PIN);
   0:	82 b3       	in	r24, 0x12	; 18
	DDR_REGISTER(B_ROTARY_PORT) &= ~(1 << B_ROTARY_PIN);
   2:	82 fb       	bst	r24, 2
	A_ROTARY_PORT |= (1 << A_ROTARY_PIN);
   4:	88 27       	eor	r24, r24
	B_ROTARY_PORT |= (1 << B_ROTARY_PIN);
   6:	80 f9       	bld	r24, 0

	sei();
   8:	91 e0       	ldi	r25, 0x01	; 1
   a:	89 27       	eor	r24, r25
   c:	08 95       	ret

Disassembly of section .text.rotary_setClockwiseCallback:

00000000 <rotary_setClockwiseCallback>:
pTypeRotaryCallback rotaryClockwiseCallback;
pTypeRotaryCallback rotaryCounterClockwiseCallback;
/* FUNCTION DEFINITION *******************************************************/

void rotary_init() {
	DDR_REGISTER(A_ROTARY_PORT) &= ~(1 << A_ROTARY_PIN);
   0:	90 93 00 00 	sts	0x0000, r25	; 0x800000 <__SREG__+0x7fffc1>
	DDR_REGISTER(B_ROTARY_PORT) &= ~(1 << B_ROTARY_PIN);
	A_ROTARY_PORT |= (1 << A_ROTARY_PIN);
   4:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
	B_ROTARY_PORT |= (1 << B_ROTARY_PIN);

	sei();
   8:	08 95       	ret

Disassembly of section .text.rotary_setCounterClockwiseCallback:

00000000 <rotary_setCounterClockwiseCallback>:
pTypeRotaryCallback rotaryClockwiseCallback;
pTypeRotaryCallback rotaryCounterClockwiseCallback;
/* FUNCTION DEFINITION *******************************************************/

void rotary_init() {
	DDR_REGISTER(A_ROTARY_PORT) &= ~(1 << A_ROTARY_PIN);
   0:	90 93 00 00 	sts	0x0000, r25	; 0x800000 <__SREG__+0x7fffc1>
	DDR_REGISTER(B_ROTARY_PORT) &= ~(1 << B_ROTARY_PIN);
	A_ROTARY_PORT |= (1 << A_ROTARY_PIN);
   4:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
	B_ROTARY_PORT |= (1 << B_ROTARY_PIN);

	sei();
   8:	08 95       	ret

Disassembly of section .text.rotary_checkState:

00000000 <rotary_checkState>:
pTypeRotaryCallback rotaryClockwiseCallback;
pTypeRotaryCallback rotaryCounterClockwiseCallback;
/* FUNCTION DEFINITION *******************************************************/

void rotary_init() {
	DDR_REGISTER(A_ROTARY_PORT) &= ~(1 << A_ROTARY_PIN);
   0:	0f 93       	push	r16
	DDR_REGISTER(B_ROTARY_PORT) &= ~(1 << B_ROTARY_PIN);
   2:	1f 93       	push	r17
	A_ROTARY_PORT |= (1 << A_ROTARY_PIN);
   4:	cf 93       	push	r28
	B_ROTARY_PORT |= (1 << B_ROTARY_PIN);
   6:	df 93       	push	r29

	sei();
   8:	d0 91 00 00 	lds	r29, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   c:	c0 91 00 00 	lds	r28, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  10:	0c 2f       	mov	r16, r28
  12:	10 e0       	ldi	r17, 0x00	; 0
  14:	f8 01       	movw	r30, r16
  16:	e0 50       	subi	r30, 0x00	; 0
  18:	f0 40       	sbci	r31, 0x00	; 0
  1a:	10 82       	st	Z, r1
  1c:	0e 94 00 00 	call	0	; 0x0 <rotary_checkState>
  20:	88 23       	and	r24, r24
  22:	01 f0       	breq	.+0      	; 0x24 <rotary_checkState+0x24>
  24:	81 e0       	ldi	r24, 0x01	; 1
  26:	f8 01       	movw	r30, r16
  28:	e0 50       	subi	r30, 0x00	; 0
  2a:	f0 40       	sbci	r31, 0x00	; 0
  2c:	80 83       	st	Z, r24
  2e:	0e 94 00 00 	call	0	; 0x0 <rotary_checkState>
  32:	88 23       	and	r24, r24
  34:	01 f0       	breq	.+0      	; 0x36 <rotary_checkState+0x36>
  36:	f8 01       	movw	r30, r16
  38:	e0 50       	subi	r30, 0x00	; 0
  3a:	f0 40       	sbci	r31, 0x00	; 0
  3c:	80 81       	ld	r24, Z
  3e:	82 60       	ori	r24, 0x02	; 2
  40:	80 83       	st	Z, r24
  42:	cf 5f       	subi	r28, 0xFF	; 255
  44:	c5 30       	cpi	r28, 0x05	; 5
  46:	01 f0       	breq	.+0      	; 0x48 <rotary_checkState+0x48>
  48:	c0 93 00 00 	sts	0x0000, r28	; 0x800000 <__SREG__+0x7fffc1>
  4c:	00 c0       	rjmp	.+0      	; 0x4e <rotary_checkState+0x4e>
  4e:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
  52:	e0 e0       	ldi	r30, 0x00	; 0
  54:	f0 e0       	ldi	r31, 0x00	; 0
  56:	20 e0       	ldi	r18, 0x00	; 0
  58:	30 e0       	ldi	r19, 0x00	; 0
  5a:	8f ef       	ldi	r24, 0xFF	; 255
  5c:	91 91       	ld	r25, Z+
  5e:	89 23       	and	r24, r25
  60:	e2 17       	cp	r30, r18
  62:	f3 07       	cpc	r31, r19
  64:	01 f4       	brne	.+0      	; 0x66 <rotary_checkState+0x66>
  66:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
  6a:	9f ef       	ldi	r25, 0xFF	; 255
  6c:	9d 0f       	add	r25, r29
  6e:	92 30       	cpi	r25, 0x02	; 2
  70:	00 f0       	brcs	.+0      	; 0x72 <rotary_checkState+0x72>
  72:	80 ff       	sbrs	r24, 0
  74:	00 c0       	rjmp	.+0      	; 0x76 <rotary_checkState+0x76>
  76:	82 30       	cpi	r24, 0x02	; 2
  78:	01 f0       	breq	.+0      	; 0x7a <rotary_checkState+0x7a>
  7a:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  7e:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  82:	30 97       	sbiw	r30, 0x00	; 0
  84:	01 f0       	breq	.+0      	; 0x86 <rotary_checkState+0x86>
  86:	09 95       	icall
  88:	d0 ff       	sbrs	r29, 0
  8a:	00 c0       	rjmp	.+0      	; 0x8c <rotary_checkState+0x8c>
  8c:	d2 30       	cpi	r29, 0x02	; 2
  8e:	01 f0       	breq	.+0      	; 0x90 <rotary_checkState+0x90>
  90:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  94:	81 ff       	sbrs	r24, 1
  96:	00 c0       	rjmp	.+0      	; 0x98 <rotary_checkState+0x98>
  98:	81 30       	cpi	r24, 0x01	; 1
  9a:	01 f0       	breq	.+0      	; 0x9c <rotary_checkState+0x9c>
  9c:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  a0:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  a4:	30 97       	sbiw	r30, 0x00	; 0
  a6:	01 f0       	breq	.+0      	; 0xa8 <rotary_checkState+0xa8>
  a8:	09 95       	icall
  aa:	df 91       	pop	r29
  ac:	cf 91       	pop	r28
  ae:	1f 91       	pop	r17
  b0:	0f 91       	pop	r16
  b2:	08 95       	ret

ses_scheduler.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         000012fc  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      0000475a  00000000  00000000  00001330  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.scheduler_update 0000004c  00000000  00000000  00005a8a  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.scheduler_init 0000001a  00000000  00000000  00005ad6  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.scheduler_add 00000050  00000000  00000000  00005af0  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text.scheduler_remove 00000072  00000000  00000000  00005b40  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.scheduler_run 0000005c  00000000  00000000  00005bb2  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text.taskcount 00000024  00000000  00000000  00005c0e  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .text.scheduler_getTime 00000012  00000000  00000000  00005c32  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 12 .text.scheduler_setTime 0000001e  00000000  00000000  00005c44  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 13 .text.getReadableTime 00000098  00000000  00000000  00005c62  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 14 .text.clearTaskList 0000000e  00000000  00000000  00005cfa  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 15 .bss.currentTime 00000004  00000000  00000000  00005d08  2**0
                  ALLOC
 16 .bss.taskList 00000002  00000000  00000000  00005d08  2**0
                  ALLOC
 17 .comment      00000031  00000000  00000000  00005d08  2**0
                  CONTENTS, READONLY

Disassembly of section .text.scheduler_update:

00000000 <scheduler_update>:
	readableTime.minute = tempTime % 60;
	return readableTime;
}

void clearTaskList() {
	free(taskList);
   0:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   4:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   8:	a0 91 00 00 	lds	r26, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   c:	b0 91 00 00 	lds	r27, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  10:	01 96       	adiw	r24, 0x01	; 1
  12:	a1 1d       	adc	r26, r1
  14:	b1 1d       	adc	r27, r1
  16:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
  1a:	90 93 00 00 	sts	0x0000, r25	; 0x800000 <__SREG__+0x7fffc1>
  1e:	a0 93 00 00 	sts	0x0000, r26	; 0x800000 <__SREG__+0x7fffc1>
  22:	b0 93 00 00 	sts	0x0000, r27	; 0x800000 <__SREG__+0x7fffc1>
  26:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  2a:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  2e:	30 97       	sbiw	r30, 0x00	; 0
  30:	01 f0       	breq	.+0      	; 0x32 <scheduler_update+0x32>
  32:	84 81       	ldd	r24, Z+4	; 0x04
  34:	95 81       	ldd	r25, Z+5	; 0x05
  36:	89 2b       	or	r24, r25
  38:	01 f0       	breq	.+0      	; 0x3a <scheduler_update+0x3a>
  3a:	80 85       	ldd	r24, Z+8	; 0x08
  3c:	81 60       	ori	r24, 0x01	; 1
  3e:	80 87       	std	Z+8, r24	; 0x08
  40:	01 84       	ldd	r0, Z+9	; 0x09
  42:	f2 85       	ldd	r31, Z+10	; 0x0a
  44:	e0 2d       	mov	r30, r0
  46:	30 97       	sbiw	r30, 0x00	; 0
  48:	01 f4       	brne	.+0      	; 0x4a <scheduler_update+0x4a>
  4a:	08 95       	ret

Disassembly of section .text.scheduler_init:

00000000 <scheduler_init>:
   0:	80 e0       	ldi	r24, 0x00	; 0
   2:	90 e0       	ldi	r25, 0x00	; 0
   4:	0e 94 00 00 	call	0	; 0x0 <scheduler_init>
   8:	0e 94 00 00 	call	0	; 0x0 <scheduler_init>
   c:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  10:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  14:	0e 94 00 00 	call	0	; 0x0 <scheduler_init>
  18:	08 95       	ret

Disassembly of section .text.scheduler_add:

00000000 <scheduler_add>:
   0:	dc 01       	movw	r26, r24
   2:	00 97       	sbiw	r24, 0x00	; 0
   4:	01 f0       	breq	.+0      	; 0x6 <scheduler_add+0x6>
   6:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   a:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   e:	30 97       	sbiw	r30, 0x00	; 0
  10:	01 f4       	brne	.+0      	; 0x12 <scheduler_add+0x12>
  12:	90 93 00 00 	sts	0x0000, r25	; 0x800000 <__SREG__+0x7fffc1>
  16:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
  1a:	81 e0       	ldi	r24, 0x01	; 1
  1c:	08 95       	ret
  1e:	40 81       	ld	r20, Z
  20:	51 81       	ldd	r21, Z+1	; 0x01
  22:	f9 01       	movw	r30, r18
  24:	2d 91       	ld	r18, X+
  26:	3c 91       	ld	r19, X
  28:	11 97       	sbiw	r26, 0x01	; 1
  2a:	42 17       	cp	r20, r18
  2c:	53 07       	cpc	r21, r19
  2e:	01 f0       	breq	.+0      	; 0x30 <scheduler_add+0x30>
  30:	21 85       	ldd	r18, Z+9	; 0x09
  32:	32 85       	ldd	r19, Z+10	; 0x0a
  34:	21 15       	cp	r18, r1
  36:	31 05       	cpc	r19, r1
  38:	01 f4       	brne	.+0      	; 0x3a <scheduler_add+0x3a>
  3a:	8f b7       	in	r24, 0x3f	; 63
  3c:	f8 94       	cli
  3e:	b2 87       	std	Z+10, r27	; 0x0a
  40:	a1 87       	std	Z+9, r26	; 0x09
  42:	8f bf       	out	0x3f, r24	; 63
  44:	81 e0       	ldi	r24, 0x01	; 1
  46:	08 95       	ret
  48:	80 e0       	ldi	r24, 0x00	; 0
  4a:	08 95       	ret
  4c:	80 e0       	ldi	r24, 0x00	; 0
  4e:	08 95       	ret

Disassembly of section .text.scheduler_remove:

00000000 <scheduler_remove>:
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
   6:	a0 91 00 00 	lds	r26, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   a:	b0 91 00 00 	lds	r27, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   e:	10 97       	sbiw	r26, 0x00	; 0
  10:	01 f0       	breq	.+0      	; 0x12 <scheduler_remove+0x12>
  12:	2d 91       	ld	r18, X+
  14:	3c 91       	ld	r19, X
  16:	11 97       	sbiw	r26, 0x01	; 1
  18:	88 81       	ld	r24, Y
  1a:	99 81       	ldd	r25, Y+1	; 0x01
  1c:	28 17       	cp	r18, r24
  1e:	39 07       	cpc	r19, r25
  20:	01 f4       	brne	.+0      	; 0x22 <scheduler_remove+0x22>
  22:	19 96       	adiw	r26, 0x09	; 9
  24:	8d 91       	ld	r24, X+
  26:	9c 91       	ld	r25, X
  28:	1a 97       	sbiw	r26, 0x0a	; 10
  2a:	90 93 00 00 	sts	0x0000, r25	; 0x800000 <__SREG__+0x7fffc1>
  2e:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
  32:	00 c0       	rjmp	.+0      	; 0x34 <scheduler_remove+0x34>
  34:	19 96       	adiw	r26, 0x09	; 9
  36:	ed 91       	ld	r30, X+
  38:	fc 91       	ld	r31, X
  3a:	1a 97       	sbiw	r26, 0x0a	; 10
  3c:	00 c0       	rjmp	.+0      	; 0x3e <scheduler_remove+0x3e>
  3e:	f9 01       	movw	r30, r18
  40:	40 81       	ld	r20, Z
  42:	51 81       	ldd	r21, Z+1	; 0x01
  44:	28 81       	ld	r18, Y
  46:	39 81       	ldd	r19, Y+1	; 0x01
  48:	42 17       	cp	r20, r18
  4a:	53 07       	cpc	r21, r19
  4c:	01 f4       	brne	.+0      	; 0x4e <scheduler_remove+0x4e>
  4e:	8f b7       	in	r24, 0x3f	; 63
  50:	f8 94       	cli
  52:	21 85       	ldd	r18, Z+9	; 0x09
  54:	32 85       	ldd	r19, Z+10	; 0x0a
  56:	1a 96       	adiw	r26, 0x0a	; 10
  58:	3c 93       	st	X, r19
  5a:	2e 93       	st	-X, r18
  5c:	19 97       	sbiw	r26, 0x09	; 9
  5e:	8f bf       	out	0x3f, r24	; 63
  60:	21 85       	ldd	r18, Z+9	; 0x09
  62:	32 85       	ldd	r19, Z+10	; 0x0a
  64:	df 01       	movw	r26, r30
  66:	21 15       	cp	r18, r1
  68:	31 05       	cpc	r19, r1
  6a:	01 f4       	brne	.+0      	; 0x6c <scheduler_remove+0x6c>
  6c:	df 91       	pop	r29
  6e:	cf 91       	pop	r28
  70:	08 95       	ret

Disassembly of section .text.scheduler_run:

00000000 <scheduler_run>:
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	c0 91 00 00 	lds	r28, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   8:	d0 91 00 00 	lds	r29, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   c:	20 97       	sbiw	r28, 0x00	; 0
   e:	01 f0       	breq	.+0      	; 0x10 <scheduler_run+0x10>
  10:	88 85       	ldd	r24, Y+8	; 0x08
  12:	80 ff       	sbrs	r24, 0
  14:	00 c0       	rjmp	.+0      	; 0x16 <scheduler_run+0x16>
  16:	8c 81       	ldd	r24, Y+4	; 0x04
  18:	9d 81       	ldd	r25, Y+5	; 0x05
  1a:	01 97       	sbiw	r24, 0x01	; 1
  1c:	9d 83       	std	Y+5, r25	; 0x05
  1e:	8c 83       	std	Y+4, r24	; 0x04
  20:	88 85       	ldd	r24, Y+8	; 0x08
  22:	8e 7f       	andi	r24, 0xFE	; 254
  24:	88 87       	std	Y+8, r24	; 0x08
  26:	8c 81       	ldd	r24, Y+4	; 0x04
  28:	9d 81       	ldd	r25, Y+5	; 0x05
  2a:	89 2b       	or	r24, r25
  2c:	01 f4       	brne	.+0      	; 0x2e <scheduler_run+0x2e>
  2e:	e8 81       	ld	r30, Y
  30:	f9 81       	ldd	r31, Y+1	; 0x01
  32:	8a 81       	ldd	r24, Y+2	; 0x02
  34:	9b 81       	ldd	r25, Y+3	; 0x03
  36:	09 95       	icall
  38:	8e 81       	ldd	r24, Y+6	; 0x06
  3a:	9f 81       	ldd	r25, Y+7	; 0x07
  3c:	00 97       	sbiw	r24, 0x00	; 0
  3e:	01 f0       	breq	.+0      	; 0x40 <scheduler_run+0x40>
  40:	9d 83       	std	Y+5, r25	; 0x05
  42:	8c 83       	std	Y+4, r24	; 0x04
  44:	00 c0       	rjmp	.+0      	; 0x46 <scheduler_run+0x46>
  46:	ce 01       	movw	r24, r28
  48:	0e 94 00 00 	call	0	; 0x0 <scheduler_run>
  4c:	09 84       	ldd	r0, Y+9	; 0x09
  4e:	da 85       	ldd	r29, Y+10	; 0x0a
  50:	c0 2d       	mov	r28, r0
  52:	20 97       	sbiw	r28, 0x00	; 0
  54:	01 f4       	brne	.+0      	; 0x56 <scheduler_run+0x56>
  56:	df 91       	pop	r29
  58:	cf 91       	pop	r28
  5a:	08 95       	ret

Disassembly of section .text.taskcount:

00000000 <taskcount>:
   0:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   4:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   8:	30 97       	sbiw	r30, 0x00	; 0
   a:	01 f0       	breq	.+0      	; 0xc <taskcount+0xc>
   c:	80 e0       	ldi	r24, 0x00	; 0
   e:	90 e0       	ldi	r25, 0x00	; 0
  10:	01 96       	adiw	r24, 0x01	; 1
  12:	01 84       	ldd	r0, Z+9	; 0x09
  14:	f2 85       	ldd	r31, Z+10	; 0x0a
  16:	e0 2d       	mov	r30, r0
  18:	30 97       	sbiw	r30, 0x00	; 0
  1a:	01 f4       	brne	.+0      	; 0x1c <taskcount+0x1c>
  1c:	08 95       	ret
  1e:	80 e0       	ldi	r24, 0x00	; 0
  20:	90 e0       	ldi	r25, 0x00	; 0
  22:	08 95       	ret

Disassembly of section .text.scheduler_getTime:

00000000 <scheduler_getTime>:
   0:	60 91 00 00 	lds	r22, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   4:	70 91 00 00 	lds	r23, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   8:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   c:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  10:	08 95       	ret

Disassembly of section .text.scheduler_setTime:

00000000 <scheduler_setTime>:
   0:	9b 01       	movw	r18, r22
   2:	ac 01       	movw	r20, r24
   4:	a8 ee       	ldi	r26, 0xE8	; 232
   6:	b3 e0       	ldi	r27, 0x03	; 3
   8:	0e 94 00 00 	call	0	; 0x0 <scheduler_setTime>
   c:	60 93 00 00 	sts	0x0000, r22	; 0x800000 <__SREG__+0x7fffc1>
  10:	70 93 00 00 	sts	0x0000, r23	; 0x800000 <__SREG__+0x7fffc1>
  14:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
  18:	90 93 00 00 	sts	0x0000, r25	; 0x800000 <__SREG__+0x7fffc1>
  1c:	08 95       	ret

Disassembly of section .text.getReadableTime:

00000000 <getReadableTime>:
   0:	bf 92       	push	r11
   2:	cf 92       	push	r12
   4:	df 92       	push	r13
   6:	ef 92       	push	r14
   8:	ff 92       	push	r15
   a:	0f 93       	push	r16
   c:	1f 93       	push	r17
   e:	cf 93       	push	r28
  10:	df 93       	push	r29
  12:	00 d0       	rcall	.+0      	; 0x14 <getReadableTime+0x14>
  14:	00 d0       	rcall	.+0      	; 0x16 <getReadableTime+0x16>
  16:	1f 92       	push	r1
  18:	cd b7       	in	r28, 0x3d	; 61
  1a:	de b7       	in	r29, 0x3e	; 62
  1c:	60 91 00 00 	lds	r22, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  20:	70 91 00 00 	lds	r23, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  24:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  28:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  2c:	28 ee       	ldi	r18, 0xE8	; 232
  2e:	33 e0       	ldi	r19, 0x03	; 3
  30:	40 e0       	ldi	r20, 0x00	; 0
  32:	50 e0       	ldi	r21, 0x00	; 0
  34:	0e 94 00 00 	call	0	; 0x0 <getReadableTime>
  38:	16 2f       	mov	r17, r22
  3a:	b7 2e       	mov	r11, r23
  3c:	0f 2e       	mov	r0, r31
  3e:	fc e3       	ldi	r31, 0x3C	; 60
  40:	cf 2e       	mov	r12, r31
  42:	d1 2c       	mov	r13, r1
  44:	e1 2c       	mov	r14, r1
  46:	f1 2c       	mov	r15, r1
  48:	f0 2d       	mov	r31, r0
  4a:	ca 01       	movw	r24, r20
  4c:	b9 01       	movw	r22, r18
  4e:	a7 01       	movw	r20, r14
  50:	96 01       	movw	r18, r12
  52:	0e 94 00 00 	call	0	; 0x0 <getReadableTime>
  56:	06 2f       	mov	r16, r22
  58:	ca 01       	movw	r24, r20
  5a:	b9 01       	movw	r22, r18
  5c:	a7 01       	movw	r20, r14
  5e:	96 01       	movw	r18, r12
  60:	0e 94 00 00 	call	0	; 0x0 <getReadableTime>
  64:	36 2f       	mov	r19, r22
  66:	81 2f       	mov	r24, r17
  68:	9b 2d       	mov	r25, r11
  6a:	9d 83       	std	Y+5, r25	; 0x05
  6c:	8c 83       	std	Y+4, r24	; 0x04
  6e:	51 2f       	mov	r21, r17
  70:	6d 81       	ldd	r22, Y+5	; 0x05
  72:	40 2f       	mov	r20, r16
  74:	70 e0       	ldi	r23, 0x00	; 0
  76:	80 e0       	ldi	r24, 0x00	; 0
  78:	90 e0       	ldi	r25, 0x00	; 0
  7a:	0f 90       	pop	r0
  7c:	0f 90       	pop	r0
  7e:	0f 90       	pop	r0
  80:	0f 90       	pop	r0
  82:	0f 90       	pop	r0
  84:	df 91       	pop	r29
  86:	cf 91       	pop	r28
  88:	1f 91       	pop	r17
  8a:	0f 91       	pop	r16
  8c:	ff 90       	pop	r15
  8e:	ef 90       	pop	r14
  90:	df 90       	pop	r13
  92:	cf 90       	pop	r12
  94:	bf 90       	pop	r11
  96:	08 95       	ret

Disassembly of section .text.clearTaskList:

00000000 <clearTaskList>:
   0:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   4:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   8:	0e 94 00 00 	call	0	; 0x0 <clearTaskList>
   c:	08 95       	ret

ses_timer.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         000010bc  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      000045a2  00000000  00000000  000010f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.timer2_setCallback 0000000a  00000000  00000000  00005692  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.timer2_start 0000003a  00000000  00000000  0000569c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .text.timer2_stop 00000016  00000000  00000000  000056d6  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .text.timer1_setCallback 0000000a  00000000  00000000  000056ec  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.timer1_start 00000040  00000000  00000000  000056f6  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 10 .text.timer1_stop 00000016  00000000  00000000  00005736  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .text.timer5_setCallBack 0000000a  00000000  00000000  0000574c  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 12 .text.timer5_start 00000046  00000000  00000000  00005756  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .text.timer5_stop 00000016  00000000  00000000  0000579c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .text.__vector_17 0000005a  00000000  00000000  000057b2  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 15 .text.__vector_13 0000005a  00000000  00000000  0000580c  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 16 .text.__vector_47 0000005a  00000000  00000000  00005866  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 17 .comment      00000031  00000000  00000000  000058c0  2**0
                  CONTENTS, READONLY

Disassembly of section .text.timer2_setCallback:

00000000 <timer2_setCallback>:
ISR(TIMER2_COMPA_vect) {
	if (timer2CallBack != NULL) {
		timer2CallBack();
	}
}
ISR(TIMER5_COMPA_vect) {
   0:	90 93 00 00 	sts	0x0000, r25	; 0x800000 <__SREG__+0x7fffc1>
   4:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
   8:	08 95       	ret

Disassembly of section .text.timer2_start:

00000000 <timer2_start>:
   0:	e4 e6       	ldi	r30, 0x64	; 100
   2:	f0 e0       	ldi	r31, 0x00	; 0
   4:	80 81       	ld	r24, Z
   6:	8f 7b       	andi	r24, 0xBF	; 191
   8:	80 83       	st	Z, r24
   a:	e0 eb       	ldi	r30, 0xB0	; 176
   c:	f0 e0       	ldi	r31, 0x00	; 0
   e:	80 81       	ld	r24, Z
  10:	82 60       	ori	r24, 0x02	; 2
  12:	80 83       	st	Z, r24
  14:	e1 eb       	ldi	r30, 0xB1	; 177
  16:	f0 e0       	ldi	r31, 0x00	; 0
  18:	80 81       	ld	r24, Z
  1a:	87 7f       	andi	r24, 0xF7	; 247
  1c:	80 83       	st	Z, r24
  1e:	80 81       	ld	r24, Z
  20:	84 60       	ori	r24, 0x04	; 4
  22:	80 83       	st	Z, r24
  24:	b9 9a       	sbi	0x17, 1	; 23
	if (timer5CallBack != NULL) {
  26:	8a ef       	ldi	r24, 0xFA	; 250
  28:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__SREG__+0x800074>
  2c:	e0 e7       	ldi	r30, 0x70	; 112
  2e:	f0 e0       	ldi	r31, 0x00	; 0
  30:	80 81       	ld	r24, Z
		timer5CallBack();
  32:	82 60       	ori	r24, 0x02	; 2
	}
}
  34:	80 83       	st	Z, r24
  36:	78 94       	sei
  38:	08 95       	ret

Disassembly of section .text.timer2_stop:

00000000 <timer2_stop>:
ISR(TIMER2_COMPA_vect) {
	if (timer2CallBack != NULL) {
		timer2CallBack();
	}
}
ISR(TIMER5_COMPA_vect) {
   0:	e4 e6       	ldi	r30, 0x64	; 100
   2:	f0 e0       	ldi	r31, 0x00	; 0
   4:	80 81       	ld	r24, Z
   6:	80 64       	ori	r24, 0x40	; 64
   8:	80 83       	st	Z, r24
   a:	e0 e7       	ldi	r30, 0x70	; 112
   c:	f0 e0       	ldi	r31, 0x00	; 0
   e:	80 81       	ld	r24, Z
  10:	8d 7f       	andi	r24, 0xFD	; 253
  12:	80 83       	st	Z, r24
  14:	08 95       	ret

Disassembly of section .text.timer1_setCallback:

00000000 <timer1_setCallback>:
   0:	90 93 00 00 	sts	0x0000, r25	; 0x800000 <__SREG__+0x7fffc1>
   4:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
   8:	08 95       	ret

Disassembly of section .text.timer1_start:

00000000 <timer1_start>:
   0:	e4 e6       	ldi	r30, 0x64	; 100
   2:	f0 e0       	ldi	r31, 0x00	; 0
   4:	80 81       	ld	r24, Z
   6:	87 7f       	andi	r24, 0xF7	; 247
   8:	80 83       	st	Z, r24
   a:	e0 e8       	ldi	r30, 0x80	; 128
   c:	f0 e0       	ldi	r31, 0x00	; 0
   e:	80 81       	ld	r24, Z
  10:	8e 7f       	andi	r24, 0xFE	; 254
  12:	80 83       	st	Z, r24
  14:	e1 e8       	ldi	r30, 0x81	; 129
  16:	f0 e0       	ldi	r31, 0x00	; 0
  18:	80 81       	ld	r24, Z
  1a:	88 60       	ori	r24, 0x08	; 8
  1c:	80 83       	st	Z, r24
  1e:	80 81       	ld	r24, Z
  20:	83 60       	ori	r24, 0x03	; 3
  22:	80 83       	st	Z, r24
  24:	b1 9a       	sbi	0x16, 1	; 22
	if (timer5CallBack != NULL) {
  26:	82 ee       	ldi	r24, 0xE2	; 226
  28:	94 e0       	ldi	r25, 0x04	; 4
  2a:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__SREG__+0x80004a>
  2e:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__SREG__+0x800049>
		timer5CallBack();
  32:	ef e6       	ldi	r30, 0x6F	; 111
	}
}
  34:	f0 e0       	ldi	r31, 0x00	; 0
  36:	80 81       	ld	r24, Z
  38:	82 60       	ori	r24, 0x02	; 2
  3a:	80 83       	st	Z, r24
  3c:	78 94       	sei
  3e:	08 95       	ret

Disassembly of section .text.timer1_stop:

00000000 <timer1_stop>:
ISR(TIMER2_COMPA_vect) {
	if (timer2CallBack != NULL) {
		timer2CallBack();
	}
}
ISR(TIMER5_COMPA_vect) {
   0:	e4 e6       	ldi	r30, 0x64	; 100
   2:	f0 e0       	ldi	r31, 0x00	; 0
   4:	80 81       	ld	r24, Z
   6:	88 60       	ori	r24, 0x08	; 8
   8:	80 83       	st	Z, r24
   a:	ef e6       	ldi	r30, 0x6F	; 111
   c:	f0 e0       	ldi	r31, 0x00	; 0
   e:	80 81       	ld	r24, Z
  10:	8d 7f       	andi	r24, 0xFD	; 253
  12:	80 83       	st	Z, r24
  14:	08 95       	ret

Disassembly of section .text.timer5_setCallBack:

00000000 <timer5_setCallBack>:
   0:	90 93 00 00 	sts	0x0000, r25	; 0x800000 <__SREG__+0x7fffc1>
   4:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
   8:	08 95       	ret

Disassembly of section .text.timer5_start:

00000000 <timer5_start>:
   0:	e5 e6       	ldi	r30, 0x65	; 101
   2:	f0 e0       	ldi	r31, 0x00	; 0
   4:	80 81       	ld	r24, Z
   6:	8f 7d       	andi	r24, 0xDF	; 223
   8:	80 83       	st	Z, r24
   a:	e0 e2       	ldi	r30, 0x20	; 32
   c:	f1 e0       	ldi	r31, 0x01	; 1
   e:	80 81       	ld	r24, Z
  10:	8d 7f       	andi	r24, 0xFD	; 253
  12:	80 83       	st	Z, r24
  14:	e1 e2       	ldi	r30, 0x21	; 33
  16:	f1 e0       	ldi	r31, 0x01	; 1
  18:	80 81       	ld	r24, Z
  1a:	88 60       	ori	r24, 0x08	; 8
  1c:	80 83       	st	Z, r24
  1e:	80 81       	ld	r24, Z
  20:	8f 7e       	andi	r24, 0xEF	; 239
  22:	80 83       	st	Z, r24
  24:	80 81       	ld	r24, Z
	if (timer5CallBack != NULL) {
  26:	83 60       	ori	r24, 0x03	; 3
  28:	80 83       	st	Z, r24
  2a:	d1 9a       	sbi	0x1a, 1	; 26
  2c:	80 e0       	ldi	r24, 0x00	; 0
  2e:	94 e6       	ldi	r25, 0x64	; 100
  30:	90 93 29 01 	sts	0x0129, r25	; 0x800129 <__SREG__+0x8000ea>
		timer5CallBack();
	}
}
  34:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__SREG__+0x8000e9>
  38:	e3 e7       	ldi	r30, 0x73	; 115
  3a:	f0 e0       	ldi	r31, 0x00	; 0
  3c:	80 81       	ld	r24, Z
  3e:	82 60       	ori	r24, 0x02	; 2
  40:	80 83       	st	Z, r24
  42:	78 94       	sei
  44:	08 95       	ret

Disassembly of section .text.timer5_stop:

00000000 <timer5_stop>:
ISR(TIMER2_COMPA_vect) {
	if (timer2CallBack != NULL) {
		timer2CallBack();
	}
}
ISR(TIMER5_COMPA_vect) {
   0:	e5 e6       	ldi	r30, 0x65	; 101
   2:	f0 e0       	ldi	r31, 0x00	; 0
   4:	80 81       	ld	r24, Z
   6:	80 62       	ori	r24, 0x20	; 32
   8:	80 83       	st	Z, r24
   a:	e3 e7       	ldi	r30, 0x73	; 115
   c:	f0 e0       	ldi	r31, 0x00	; 0
   e:	80 81       	ld	r24, Z
  10:	8d 7f       	andi	r24, 0xFD	; 253
  12:	80 83       	st	Z, r24
  14:	08 95       	ret

Disassembly of section .text.__vector_17:

00000000 <__vector_17>:
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	0b b6       	in	r0, 0x3b	; 59
   c:	0f 92       	push	r0
   e:	2f 93       	push	r18
  10:	3f 93       	push	r19
  12:	4f 93       	push	r20
  14:	5f 93       	push	r21
  16:	6f 93       	push	r22
  18:	7f 93       	push	r23
  1a:	8f 93       	push	r24
  1c:	9f 93       	push	r25
  1e:	af 93       	push	r26
  20:	bf 93       	push	r27
  22:	ef 93       	push	r30
  24:	ff 93       	push	r31
	if (timer5CallBack != NULL) {
  26:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  2a:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  2e:	30 97       	sbiw	r30, 0x00	; 0
  30:	01 f0       	breq	.+0      	; 0x32 <__vector_17+0x32>
		timer5CallBack();
  32:	09 95       	icall
	}
}
  34:	ff 91       	pop	r31
  36:	ef 91       	pop	r30
  38:	bf 91       	pop	r27
  3a:	af 91       	pop	r26
  3c:	9f 91       	pop	r25
  3e:	8f 91       	pop	r24
  40:	7f 91       	pop	r23
  42:	6f 91       	pop	r22
  44:	5f 91       	pop	r21
  46:	4f 91       	pop	r20
  48:	3f 91       	pop	r19
  4a:	2f 91       	pop	r18
  4c:	0f 90       	pop	r0
  4e:	0b be       	out	0x3b, r0	; 59
  50:	0f 90       	pop	r0
  52:	0f be       	out	0x3f, r0	; 63
  54:	0f 90       	pop	r0
  56:	1f 90       	pop	r1
  58:	18 95       	reti

Disassembly of section .text.__vector_13:

00000000 <__vector_13>:
ISR(TIMER2_COMPA_vect) {
	if (timer2CallBack != NULL) {
		timer2CallBack();
	}
}
ISR(TIMER5_COMPA_vect) {
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	0b b6       	in	r0, 0x3b	; 59
   c:	0f 92       	push	r0
   e:	2f 93       	push	r18
  10:	3f 93       	push	r19
  12:	4f 93       	push	r20
  14:	5f 93       	push	r21
  16:	6f 93       	push	r22
  18:	7f 93       	push	r23
  1a:	8f 93       	push	r24
  1c:	9f 93       	push	r25
  1e:	af 93       	push	r26
  20:	bf 93       	push	r27
  22:	ef 93       	push	r30
  24:	ff 93       	push	r31
	if (timer5CallBack != NULL) {
  26:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  2a:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  2e:	30 97       	sbiw	r30, 0x00	; 0
  30:	01 f0       	breq	.+0      	; 0x32 <__vector_13+0x32>
		timer5CallBack();
  32:	09 95       	icall
	}
}
  34:	ff 91       	pop	r31
  36:	ef 91       	pop	r30
  38:	bf 91       	pop	r27
  3a:	af 91       	pop	r26
  3c:	9f 91       	pop	r25
  3e:	8f 91       	pop	r24
  40:	7f 91       	pop	r23
  42:	6f 91       	pop	r22
  44:	5f 91       	pop	r21
  46:	4f 91       	pop	r20
  48:	3f 91       	pop	r19
  4a:	2f 91       	pop	r18
  4c:	0f 90       	pop	r0
  4e:	0b be       	out	0x3b, r0	; 59
  50:	0f 90       	pop	r0
  52:	0f be       	out	0x3f, r0	; 63
  54:	0f 90       	pop	r0
  56:	1f 90       	pop	r1
  58:	18 95       	reti

Disassembly of section .text.__vector_47:

00000000 <__vector_47>:
ISR(TIMER2_COMPA_vect) {
	if (timer2CallBack != NULL) {
		timer2CallBack();
	}
}
ISR(TIMER5_COMPA_vect) {
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	0b b6       	in	r0, 0x3b	; 59
   c:	0f 92       	push	r0
   e:	2f 93       	push	r18
  10:	3f 93       	push	r19
  12:	4f 93       	push	r20
  14:	5f 93       	push	r21
  16:	6f 93       	push	r22
  18:	7f 93       	push	r23
  1a:	8f 93       	push	r24
  1c:	9f 93       	push	r25
  1e:	af 93       	push	r26
  20:	bf 93       	push	r27
  22:	ef 93       	push	r30
  24:	ff 93       	push	r31
	if (timer5CallBack != NULL) {
  26:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  2a:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  2e:	30 97       	sbiw	r30, 0x00	; 0
  30:	01 f0       	breq	.+0      	; 0x32 <__vector_47+0x32>
		timer5CallBack();
  32:	09 95       	icall
	}
}
  34:	ff 91       	pop	r31
  36:	ef 91       	pop	r30
  38:	bf 91       	pop	r27
  3a:	af 91       	pop	r26
  3c:	9f 91       	pop	r25
  3e:	8f 91       	pop	r24
  40:	7f 91       	pop	r23
  42:	6f 91       	pop	r22
  44:	5f 91       	pop	r21
  46:	4f 91       	pop	r20
  48:	3f 91       	pop	r19
  4a:	2f 91       	pop	r18
  4c:	0f 90       	pop	r0
  4e:	0b be       	out	0x3b, r0	; 59
  50:	0f 90       	pop	r0
  52:	0f be       	out	0x3f, r0	; 63
  54:	0f 90       	pop	r0
  56:	1f 90       	pop	r1
  58:	18 95       	reti
