#include "ses_button.h"
#include "ses_led.h"
#include "ses_pwm.h"
#include "ses_scheduler.h"
#include "ses_timer.h"
#include "ses_fsm.h"
#include "ses_uart.h"
//#include "ses_lcd.h"

#define TRANSITION(newState) (fsm->state = newState, RET_TRANSITION);


Fsm fsmAlarmClock;			// Alarm clock state machine
myTime systemTime;
myTime alarmTime;
bool alarmTimeSet = false;
taskDescriptor tdDisplaySystemTime;
taskDescriptor tdCompareAlarmSystemTime;
taskDescriptor tdTimer5Sec;
taskDescriptor tdRedLedBlink4Hz;
taskDescriptor tdRedLedOff;


void joystickPressed(void * param);
void rotaryPressed(void * param);
void displaySystemTime(void * param);
void compareAlarmSystemTime(void * param);
void timer5SecExpired(void * param);
void toggleRedLED(void * param);
void offRedLED(void * param);

// States of alarm clock
fsmReturnStatus setSystemTime(Fsm *, const Event *);
fsmReturnStatus systemHoursSet(Fsm *, const Event *);
fsmReturnStatus systemTimeDisplayAlarmOff(Fsm *, const Event *);
fsmReturnStatus systemTimeDisplayAlarmOnNotSet(Fsm *, const Event *);
fsmReturnStatus systemTimeDisplayAlarmOnSet(Fsm *, const Event *);
fsmReturnStatus alarmOccured(Fsm *, const Event *);
fsmReturnStatus setAlarmTime(Fsm *, const Event *);
fsmReturnStatus alarmHoursSet(Fsm *, const Event *);



int main(void) {
	button_init(true);
	led_greenInit();
	led_redInit();
	led_yellowInit();
	uart_init(57600);
	scheduler_init();
	fsmAlarmClock.isAlarmEnabled = false;
	fsm_init(&fsmAlarmClock, setSystemTime);

	button_setRotaryButtonCallback(&rotaryPressed);
	button_setJoystickButtonCallback(&joystickPressed);

	tdDisplaySystemTime.task = &displaySystemTime;
	tdDisplaySystemTime.period = 1000;

	tdCompareAlarmSystemTime.task = &compareAlarmSystemTime;
	tdCompareAlarmSystemTime.period = 1000;

	tdTimer5Sec.task = &timer5SecExpired;
	tdTimer5Sec.period = 0;

	tdRedLedBlink4Hz.task = &toggleRedLED;
	tdRedLedBlink4Hz.period = 250;

	tdRedLedOff.task = &offRedLED;
	tdRedLedOff.expire = 0;

	taskDescriptor tdCheckButtonsState;
	tdCheckButtonsState.task = &button_checkState;
	tdCheckButtonsState.period = 10;
	scheduler_add(&tdCheckButtonsState);

	while(1) {
		scheduler_run();
	}

	return 0;
}

void joystickPressed(void * param) {
	Event e = {.signal = JOYSTICK_PRESSED};
	fsm_dispatch(&fsmAlarmClock, &e);
}

void rotaryPressed(void * param) {
	Event e = {.signal = ROTARY_PRESSED};
	fsm_dispatch(&fsmAlarmClock, &e);
}

void displaySystemTime(void * param) {
	// TODO
	// Change For LCD
	bool lineOne = (bool) param;
	int line = 0;
	if(lineOne) {
		line = 1;
	} else {
		line = 2;
	}

	systemTime = getReadableTime();
	fprintf(uartout, "%d:%d:%d-Line:%d\r\n", systemTime.hour, systemTime.minute, systemTime.second, line);
	if(lineOne) {
		if(fsmAlarmClock.isAlarmEnabled) {
			fprintf(uartout, "Alarm: %d:%d\r\n", alarmTime.hour, alarmTime.minute);
		}

	}
	led_greenToggle();
}

void compareAlarmSystemTime(void * param) {
	if((systemTime.hour == alarmTime.hour) && (systemTime.minute == alarmTime.minute)) {
		Event e = {.signal = TIME_MATCHED};
		fsm_dispatch(&fsmAlarmClock, &e);
	}
}

void timer5SecExpired(void * param) {
	Event e = {.signal = TIMER_EXPIRED};
	fsm_dispatch(&fsmAlarmClock, &e);
}

void toggleRedLED(void * param) {
	led_redToggle();
}

void offRedLED(void * param) {
	led_redOff();
}

inline static void fsm_dispatch(Fsm* fsm, const Event* event) {
	static Event entryEvent = {.signal = ENTRY};
	static Event exitEvent = {.signal = EXIT};
	State s = fsm->state;
	fsmReturnStatus r = fsm->state(fsm, event);
	if(r == RET_TRANSITION) {
		s(fsm, &exitEvent);				//< Call exit action of last state
		fsm->state(fsm, &entryEvent);	//< Call entry action of new state
	}
}

inline static void fsm_init(Fsm* fsm, State init) {
	// ... Other initialization
	Event entryEvent = {.signal = ENTRY};
	fsm->state = init;
	fsm->state(fsm, &entryEvent);
}


fsmReturnStatus setSystemTime(Fsm * fsm, const Event * event) {
	fprintf(uartout, "setSystemTime\r\n");
	switch(event->signal) {
	case ENTRY:
		fprintf(uartout, "HH:MM\r\n");
		fprintf(uartout, "Please Enter Time!\r\n");
		systemTime.hour = 0;
		systemTime.minute = 0;
		systemTime.second = 0;
		systemTime.milli = 0;
		return RET_HANDLED;
	case JOYSTICK_PRESSED:
		return TRANSITION(systemHoursSet);
	case ROTARY_PRESSED:
		systemTime.hour++;
		fprintf(uartout, "%d:MM\r\n", systemTime.hour);
		fprintf(uartout, "Please Enter Time!\r\n");
		return RET_HANDLED;
	case EXIT:
		alarmTimeSet = false;
		return RET_HANDLED;
	default:
		return RET_IGNORED;
	}
}

fsmReturnStatus systemHoursSet(Fsm * fsm, const Event * event) {
	fprintf(uartout, "systemHoursSet\r\n");
	systemTime_t tempTime;
	switch(event->signal) {
	case ENTRY:
		fprintf(uartout, "%d:MM\r\n", systemTime.hour);
		fprintf(uartout, "Please Enter Time!\r\n");
		return RET_HANDLED;
	case JOYSTICK_PRESSED:
		fprintf(uartout, "Hours = %d, Minutes = %d\r\n", systemTime.hour, systemTime.minute);
		tempTime = ((systemTime.hour * 3600) + (systemTime.minute * 60));
		scheduler_setTime(tempTime);
		tdDisplaySystemTime.param = (void *) true;
		scheduler_add(&tdDisplaySystemTime);
		return TRANSITION(systemTimeDisplayAlarmOff);
	case ROTARY_PRESSED:
		systemTime.minute++;
		fprintf(uartout, "%d:%d\r\n", systemTime.hour, systemTime.minute);
		fprintf(uartout, "Please Enter Time!\r\n");
		return RET_HANDLED;
	case EXIT:
		return RET_HANDLED;
	default:
		return RET_IGNORED;
	}
}

fsmReturnStatus systemTimeDisplayAlarmOff(Fsm * fsm, const Event * event) {
	fprintf(uartout, "systemTimeDisplayAlarmOff\r\n");
	switch(event->signal) {
	case ENTRY:
		return RET_HANDLED;
	case JOYSTICK_PRESSED:
		return TRANSITION(setAlarmTime);
	case ROTARY_PRESSED:
		if(alarmTimeSet) {
			return TRANSITION(systemTimeDisplayAlarmOnSet);
		} else {
			return TRANSITION(systemTimeDisplayAlarmOnNotSet);
		}
		return RET_HANDLED;
	case EXIT:
		return RET_HANDLED;
	default:
		return RET_IGNORED;
	}
}

fsmReturnStatus systemTimeDisplayAlarmOnNotSet(Fsm * fsm, const Event * event) {
	fprintf(uartout, "systemTimeDisplayAlarmOnNotSet\r\n");
	switch(event->signal) {
	case ENTRY:
		fsmAlarmClock.isAlarmEnabled = true;
		led_yellowOn();
		return RET_HANDLED;
	case JOYSTICK_PRESSED:
		return TRANSITION(setAlarmTime);
	case ROTARY_PRESSED:
		return TRANSITION(systemTimeDisplayAlarmOff);
	case EXIT:
		fsmAlarmClock.isAlarmEnabled = false;
		led_yellowOff();
		return RET_HANDLED;
	default:
		return RET_IGNORED;
	}
}

fsmReturnStatus systemTimeDisplayAlarmOnSet(Fsm * fsm, const Event * event) {
	fprintf(uartout, "systemTimeDisplayAlarmOnSet\r\n");
	switch(event->signal) {
	case ENTRY:
		fsmAlarmClock.isAlarmEnabled = true;
		led_yellowOn();
		scheduler_add(&tdCompareAlarmSystemTime);
		return RET_HANDLED;
	case JOYSTICK_PRESSED:
		return TRANSITION(setAlarmTime);
	case ROTARY_PRESSED:
		return TRANSITION(systemTimeDisplayAlarmOff);
	case TIME_MATCHED:
		return TRANSITION(alarmOccured);
	case EXIT:
		scheduler_remove(&tdCompareAlarmSystemTime);
		fsmAlarmClock.isAlarmEnabled = false;
		led_yellowOff();
		return RET_HANDLED;
	default:
		return RET_IGNORED;
	}
}

fsmReturnStatus alarmOccured(Fsm * fsm, const Event * event) {
	fprintf(uartout, "alarmOccured\r\n");
	switch(event->signal) {
	case ENTRY:
		tdTimer5Sec.expire = 5000;
		scheduler_add(&tdTimer5Sec);
		scheduler_add(&tdRedLedBlink4Hz);
		fprintf(uartout, "redLedAdded\r\n");
		return RET_HANDLED;
	case JOYSTICK_PRESSED:
		return TRANSITION(systemTimeDisplayAlarmOff);
	case ROTARY_PRESSED:
		return TRANSITION(systemTimeDisplayAlarmOff);
	case TIMER_EXPIRED:
		fprintf(uartout, "timer_expired\r\n");
		return TRANSITION(systemTimeDisplayAlarmOff);
	case EXIT:
		scheduler_remove(&tdRedLedBlink4Hz);
		scheduler_remove(&tdTimer5Sec);
		fprintf(uartout, "timerRemoved\r\n");
		scheduler_add(&tdRedLedOff);
		fprintf(uartout, "redLedBlinkremoved\r\n");
		return RET_HANDLED;
	default:
		return RET_IGNORED;
	}
}

fsmReturnStatus setAlarmTime(Fsm * fsm, const Event * event) {
	fprintf(uartout, "setAlarmTime\r\n");
	switch(event->signal) {
	case ENTRY:
		alarmTime.hour = 0;
		alarmTime.minute = 0;
		alarmTime.second = 0;
		alarmTime.milli = 0;
		fprintf(uartout, "HH:MM\r\n");
		scheduler_remove(&tdDisplaySystemTime);
		tdDisplaySystemTime.param = (void *) false;
		scheduler_add(&tdDisplaySystemTime);
		return RET_HANDLED;
	case JOYSTICK_PRESSED:
		return TRANSITION(alarmHoursSet);
	case ROTARY_PRESSED:
		alarmTime.hour++;
		fprintf(uartout, "%d:MM\r\n", alarmTime.hour);
		return RET_HANDLED;
	case EXIT:
		return RET_HANDLED;
	default:
		return RET_IGNORED;
	}
}

fsmReturnStatus alarmHoursSet(Fsm * fsm, const Event * event) {
	fprintf(uartout, "alarmHoursSet\r\n");
	switch(event->signal) {
	case ENTRY:
		fprintf(uartout, "%d:MM\r\n", alarmTime.hour);
		return RET_HANDLED;
	case JOYSTICK_PRESSED:
		return TRANSITION(systemTimeDisplayAlarmOff);
	case ROTARY_PRESSED:
		alarmTime.minute++;
		fprintf(uartout, "%d:%d\r\n", alarmTime.hour, alarmTime.minute);
		return RET_HANDLED;
	case EXIT:
		scheduler_remove(&tdDisplaySystemTime);
		tdDisplaySystemTime.param = (void *) true;
		scheduler_add(&tdDisplaySystemTime);
		alarmTimeSet = true;
		return RET_HANDLED;
	default:
		return RET_IGNORED;
	}
}
